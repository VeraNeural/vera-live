import type { ErrorLog } from './types';

type RepoRef = { owner: string; repo: string };

type GitHubIssueResponse = {
  html_url?: string;
  number?: number;
};

type GitHubSearchIssuesResponse = {
  total_count?: number;
  items?: Array<{ html_url?: string; state?: string; title?: string }>;
};

function signatureLine(signature: string): string {
  return `signature: ${signature}`;
}

function parseRepoFromEnv(): RepoRef {
  const explicit = (process.env.GITHUB_REPO || '').trim();
  if (explicit) {
    // Accept either "owner/repo" or a full GitHub URL.
    // Examples:
    // - VeraNeural/vera-live
    // - https://github.com/VeraNeural/vera-live
    // - https://github.com/VeraNeural/vera-live.git
    try {
      if (/^https?:\/\//i.test(explicit)) {
        const u = new URL(explicit);
        const parts = u.pathname
          .split('/')
          .map((s) => s.trim())
          .filter(Boolean);

        const owner = parts[0];
        const repoRaw = parts[1];
        const repo = (repoRaw || '').replace(/\.git$/i, '');
        if (!owner || !repo) throw new Error('invalid_github_repo');
        return { owner, repo };
      }
    } catch {
      // Fall through to owner/repo parsing.
    }

    const cleaned = explicit.replace(/^github\.com\//i, '').replace(/\.git$/i, '');
    const parts = cleaned.split('/').filter(Boolean);
    const owner = parts[0];
    const repo = parts[1];
    if (!owner || !repo) throw new Error('invalid_github_repo');
    return { owner, repo };
  }

  const owner = (process.env.GITHUB_OWNER || process.env.VERCEL_GIT_REPO_OWNER || '').trim();
  const repo = (process.env.GITHUB_REPOSITORY || process.env.VERCEL_GIT_REPO_SLUG || '').trim();
  if (owner && repo) return { owner, repo };

  throw new Error('missing_github_repo');
}

function requireGitHubToken(): string {
  const token = (process.env.GITHUB_TOKEN || '').trim();
  if (!token) throw new Error('missing_github_token');
  return token;
}

function issueTitle(error: ErrorLog): string {
  const t = (error.type || 'Error').trim();
  const msg = (error.message || '').trim();
  const short = msg.length > 80 ? `${msg.slice(0, 79)}â€¦` : msg;
  return `[VERA Self-Healing] ${t}${short ? `: ${short}` : ''}`;
}

function issueBody(error: ErrorLog): string {
  const lines: string[] = [];
  lines.push('VERA Self-Healing detected an error.');
  lines.push('');
  lines.push('<!--');
  lines.push(signatureLine(`error_type:${(error.type || 'unknown').trim() || 'unknown'}`));
  lines.push('-->');
  lines.push('');
  lines.push('## Details');
  lines.push(`- **id**: ${error.id}`);
  lines.push(`- **timestamp**: ${error.timestamp}`);
  lines.push(`- **type**: ${error.type}`);
  lines.push(`- **resolved**: ${error.resolved ? 'yes' : 'no'}`);
  if (error.file) lines.push(`- **file**: ${error.file}`);
  lines.push('');
  lines.push('## Message');
  lines.push('```');
  lines.push((error.message || '').trim());
  lines.push('```');

  if (error.stack) {
    lines.push('');
    lines.push('## Stack');
    lines.push('```');
    lines.push(String(error.stack));
    lines.push('```');
  }

  if (error.fix) {
    lines.push('');
    lines.push('## Suggested fix (detected)');
    lines.push('```json');
    lines.push(JSON.stringify(error.fix, null, 2));
    lines.push('```');
  }

  lines.push('');
  lines.push('---');
  lines.push('Generated by VERA Self-Healing.');

  return lines.join('\n');
}

async function githubFetch<T>(path: string, init: RequestInit): Promise<T> {
  const token = requireGitHubToken();

  const res = await fetch(`https://api.github.com${path}`, {
    ...init,
    headers: {
      Accept: 'application/vnd.github+json',
      'X-GitHub-Api-Version': '2022-11-28',
      'User-Agent': 'vera-live-self-healing',
      Authorization: `Bearer ${token}`,
      'Content-Type': 'application/json',
      ...(init.headers || {}),
    },
  });

  const data = (await res.json().catch(() => ({}))) as any;
  if (!res.ok) {
    const msg = typeof data?.message === 'string' ? data.message : `GitHub request failed (${res.status})`;
    throw new Error(`github_error:${msg}`);
  }
  return data as T;
}

/**
 * Returns the URL of an existing open issue that matches a signature marker in the body.
 * Uses GitHub Search API.
 */
export async function findOpenIssueUrlBySignature(signature: string): Promise<string | null> {
  const { owner, repo } = parseRepoFromEnv();
  const sig = signatureLine(signature);

  // Search query: open issues in this repo whose body contains the signature marker.
  const q = `repo:${owner}/${repo} is:issue is:open in:body "${sig}"`;
  const path = `/search/issues?q=${encodeURIComponent(q)}&per_page=5`;

  const res = await githubFetch<GitHubSearchIssuesResponse>(path, { method: 'GET' });
  const url = res?.items?.find((i) => typeof i?.html_url === 'string')?.html_url;
  return url || null;
}

function healthCheckIssueTitle(name: string): string {
  const n = (name || 'Health Check').trim();
  return `[VERA Self-Healing] HealthCheck: ${n}`;
}

function healthCheckIssueBody(input: {
  name: string;
  status: string;
  message: string;
  lastCheck: string;
  signature: string;
}): string {
  const lines: string[] = [];
  lines.push('VERA Self-Healing detected a critical health check failure.');
  lines.push('');
  lines.push('<!--');
  lines.push(signatureLine(input.signature));
  lines.push('-->');
  lines.push('');
  lines.push('## Health Check');
  lines.push(`- **name**: ${input.name}`);
  lines.push(`- **status**: ${input.status}`);
  lines.push(`- **lastCheck**: ${input.lastCheck}`);
  lines.push('');
  lines.push('## Message');
  lines.push('```');
  lines.push((input.message || '').trim());
  lines.push('```');
  lines.push('');
  lines.push('---');
  lines.push('Generated by VERA Self-Healing.');
  return lines.join('\n');
}

/**
 * Creates a GitHub issue for a critical health check.
 * Use findOpenIssueUrlBySignature() first to prevent duplicates.
 */
export async function createHealthCheckIssue(input: {
  name: string;
  status: string;
  message: string;
  lastCheck: string;
  signature: string;
}): Promise<string> {
  const { owner, repo } = parseRepoFromEnv();

  const labelsRaw = (process.env.GITHUB_ISSUE_LABELS || 'vera-self-healing').trim();
  const labels = labelsRaw
    .split(',')
    .map((s) => s.trim())
    .filter(Boolean);

  const created = await githubFetch<GitHubIssueResponse>(`/repos/${owner}/${repo}/issues`, {
    method: 'POST',
    body: JSON.stringify({
      title: healthCheckIssueTitle(input.name),
      body: healthCheckIssueBody(input),
      labels: labels.length ? labels : undefined,
    }),
  });

  if (!created.html_url) throw new Error('github_issue_missing_url');
  return created.html_url;
}

/**
 * Creates a GitHub issue with the full error details.
 * Requires env vars:
 * - GITHUB_TOKEN
 * - GITHUB_REPO (owner/repo) OR (GITHUB_OWNER + GITHUB_REPOSITORY) OR Vercel git vars.
 */
export async function createIssue(error: ErrorLog): Promise<string> {
  const { owner, repo } = parseRepoFromEnv();

  const labelsRaw = (process.env.GITHUB_ISSUE_LABELS || 'vera-self-healing').trim();
  const labels = labelsRaw
    .split(',')
    .map((s) => s.trim())
    .filter(Boolean);

  const created = await githubFetch<GitHubIssueResponse>(`/repos/${owner}/${repo}/issues`, {
    method: 'POST',
    body: JSON.stringify({
      title: issueTitle(error),
      body: issueBody(error),
      labels: labels.length ? labels : undefined,
    }),
  });

  if (!created.html_url) throw new Error('github_issue_missing_url');
  return created.html_url;
}

/**
 * Future: create a branch/commit/PR that applies a generated fix.
 * This is intentionally not implemented yet (safety).
 */
export async function createFixPR(_error: ErrorLog, _fix: string): Promise<string> {
  throw new Error('not_implemented');
}
